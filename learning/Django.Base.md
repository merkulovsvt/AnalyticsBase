merkulovsvt  
1

## #TODO

* Написать про работу requests
* Написать про то, как работает API и что это такое
* Работа с моделями (manytomany) и тд

## Полезная информация

* django-admin == manage.py
* API (Application Programming Interface) — это посредник между приложением и сервером.  
  Каждый раз, когда приложение связывается с другим приложением или с сервером, используется API.
* python manage.py --help - список всех команд, с которыми можно работать
* Порт postgreSQL - 5432, поэтому при запуске писать ... runserver 5432. По умолчанию стоит 8000.
* В PyCharm можно создать скрипт для запуска команд
* Продакшн - задеплоенный в сеть проект.
* В django очень мощная админ панель.
* Приложения надо группировать по задачам (товары, личный кабинет и тд).
* Тесты желательно создавать с самого начала.
* Функции во View(представлениях) принято называть контроллерами или вьюхами.
* Обязательно отмечать папку с migrate.py, как `Source Root` (пкм + Mark Directory as)
* Относительный путь - "../../Ссылаемый документ.html". `../` - означает подъём на уровень родительской папки (вверх).
* index.html называют главную страницу сайта. Её задают как path('', ...), те пустая строка.
* Если внутри src="..." или href="..." писать #, то переадресация на самого себя.


* Клиент - веб-браузер, приложение, ...
* Сервер - Django

#### Requests (запросы):

* __GET__ - запрос на получение данных от сервера. Считается безопасным запросом.
* __POST__ - запрос, который отправляет определенные данные на сервер. Считается небезопасным и требудет защиты.
* ...

#### Коды ответов HTTP (Responses):

* Информационные 1xx
* Успешные 2xx
* Перенаправления 3xx
* Клиентские ошибки 4xx
* Серверные ошибки 5xx

#### Traceback режим - Если что-то сломалось, то на странице отобразится Traceback страница с описанием ошибки.

* Есть `copy-and-paste view` - выводит, где и как произошла ошибка.
* Работает только из-за того, что `DEBUG = True` в `settings.py`. В ином случае будет просто выводиться номер ошибки.

#### Debug режим - тоже очень полезная функция.

## Разворачивание проекта

1. django-admin startproject project.name - создание проекта
2. python manage.py createsuperuser - создание аккаунта админа
3. python manage.py runserver - запуск проекта

* `manage.py` - главный файл проекта, через него происходит запуск всех команд. Менять его код не надо!

## Файлы корневой папки проекта

* `__init__.py` - пустой файл, по умолчанию лежащий во всех приложениях и корневой папке проекта, который говорит
  каталогу, что все файлы лежащие в нём принадлежат ему.


* `asgi.py`, `wsgi.py` - файлы, которые нужны для деплоя сервера на продакшн.


* `settings.py` - файл с настройками проекта.
    * BASE_DIR - переменная, хранящая путь до нашего проекта.
    * SECRET_KEY - обеспечивает целостность передачи данных между серверами и клиентами.
    * DEBUG - при True, например, переход на несуществующую страницу выведет пользователю ошибку, как для админа (с
      дополнительной информацией), что нужно только на локальном проекте.
    * ALLOWED_HOSTS - внутри лежат домены, как string, на которых данный проект будет доступен. Если вставить `'*'`, то
      он будет доступен на любых доменах.
    * INSTALLED_APPS - внутри лежат пути к приложениям проекта.
    * MIDDLEWARE - внутри лежат пути к промежуточным слоям проекта, например, отвечающим за CSRF токен, аутентификацию и
      тд.
    * ROOT_URLCONF - путь к URL адресам.
    * TEMPLATES - отвечает за отображение и работы с шаблонами. Внутри, например, лежит 'BACKEND' (движок для работы с
      шаблонами).
    * WSGI_APPLICATION - содержит в себе путь к файлу wsgi.
    * DATABASES - хранит информацию об используемой базе данных.
    * AUTH_PASSWORD_VALIDATORS - хранит в себе валидаторы (ограничения и требования на пароль).
    * LANGUAGE_CODE, TIME_ZONE - язык по умолчанию в проекте, временная зона, в которой располагается проект.
    * USE_I18N, USE_L10N, USE_TZ - дополнительные поля для локализации.
    * STATIC_URL - путь на то, где хранится статика (все файлы, которые не загружаются извне, например, стили,
      изображения, шрифты и тд).
    * STATICFILES_DIRS - необходимая переменная для использования статических файлов (из многих каталогов).
      Представляет из себя список или кортеж (если элемент один, то в конце обязательно надо ставить запятую) с путями
      до конкретных папок со статикой.  
      Пример: `STATICFILES_DIRS = (BASE_DIR / 'static',)`
    * DEFAULT_AUTO_FIELD - поле по умолчанию, являющееся типом данных для PK (id) в БД.


* `urls.py` - файл с путями.

## Приложения

Приложение — это группа моделей (models.py), представлений (views.py), шаблонов и URL-адресов.

1. python manage.py startapp app.name - запуск приложения
2. Добавляем приложение в список INSTALLED_APPS, лежащий в `settings.py`

### Файлы приложения

* `fixtures` - каталог, в котором хранятся фикстуры.

* `migrations` - каталог, в котором создаются файлы-миграции.


* `templates` - каталог, в котором хранится подкаталог с шаблонами. Название подкаталога такое же, как и у приложения.


* `__init__.py` - пустой файл, такой же как и в корневой папке проекта.


* `admin.py` - файл, отвечающий за регистрацию создаваемых нами моделей (таблиц) в админке.


* `apps.py` - файл, который хранит в себе информацию о конфигурации приложения.


* `models.py` - файл, в котором создаются таблицы для БД.


* `tests.py` - файл, в котором создаются тесты для проекта.


* `views.py` - файл, в котором создаются функции (контроллеры/вьюихи) для взаимодействия с БД и отображения шаблонов.

### Работа с views.py

* В контроллер передаётся переменная `request`. request - экземпляр класса HttpRequest.
* Для подключения контроллера к адресу необходимо в файле `urls.py` создать соответствующий путь и через запятую
  добавить ссылку на контроллер.
* Хранить большие данные в контроллерах не очень хорошо. Надо брать из БД

Перейдя на страницу, соответсвующую view,, увидим текст 'Hello there!'.

```
def some_view(request):  
    return HttpResponse('Hello there!')
```

Функция render(request, template_name) рендерит шаблоны.  
Перейдя на страницу, соответсвующую view, увидим шаблон template1.html.  
Через context передаются переменные в шаблон (благодаря движку django templates).

```
def some_view(request):  
    context = {'title': 'Test Template'}
    return render(request, 'app_name/template1.html', context)
```

В render мы пишем путь относительно папки templates, те `'app_name/temp_name.html'`. Вариации допустимы.

Чтобы внутри шаблона доставать переменные из context необходимо использовать `{{ context_key }}`.  
Пример: `{{ title }}` - отдаст строку 'Test Template'

### Работа с шаблонами

Это всё возможно благодаря движку django templates

* Переменные (placeholders) - {{ context_key }}
* Теги (шаблонные теги) - {% if condition %} Result {% endif %} или, например, {% for elem in data %} {{ elem }} {{%
  endfor %}}

#### Context в шаблонах

Передаётся 3 переменной в render, что находится в контроллере.

* Тип данных контекста - словарь (dict).

* Вместо context можно писать content, но не нужно.

* Обращаться к значениям по ключу нужно через `.`, а не через [...].

Пример контекста:

```
context = {'user': request.user, 'products': [{'name': 'Худи черного цвета', 'price': 123}, {'name': 'Футболка белого цвета', 'price': 222}]}
```

Достать данные в шаблоне можно так:

```
{% for elem in products %}
Name: {{ elem.name }}
Price: {{ elem.price }}
{% endfor %}
```

#### Статика в шаблонах

* Папки со статикой нет по умолчанию. Её надо самостоятельно создать и указать/изменить путь к ней в `settings.py`
  `STATIC_URL` и `STATICFILES_DIRS`.
* `{% load static %}` - обязательно добавить в html код.
* `{% static '{{elem.name}}' %}` - способ достать путь из context.
* Любой путь к файлу должен начинаться с `/`.

Конфигурация для работы со статикой:

1. Убедиться, что django.contrib,staticfiles добавлен в INSTALLED_APPS.
2. В `settings.py` имеется переменная `STATIC_URL`
3. В html-шаблоне используется тег (шаблонный тег) static для обращения к относительному пути, где хранятся статичные
   файлы

```
{% load static %} <img src="{% static '/example/example.jpg' %}">
```

#### Динамические url-ссылки в шаблонах

* Основной способ перехода по страницам внутри сайта.

  Перекидывает нас на url с аргументом name='name_from_urlpatterns'.

```
<a href="{% url 'name_from_urlpatterns' %}">Text</a>
```

#### Наследование в шаблонах

* Необходимо для принципа DRY - Don't Repeat Yourself!
* `{% load static %}` - не наследуется, поэтому в каждом ребёнке надо прописывать.
* В кавычках после extends мы пишем путь относительно папки templates, те `'app_name/temp_name.html'`. Вариации
  допустимы.

1. Создаем в папке с шаблонами base.html
2. В него добавляем всё общее и дополнительно делаем блоки `{% block block_name %} {% endblock %}`.   
   Они нужны для того, чтобы вставлять в них html-код под задачи, что не надо наследовать.
3. В детях обязательно наследуемcя: `{% extends 'base/base.html' %}` и вставляем код в
   блоки: `{% block block_name %} тут код {% endblock %}`

### Работа с models.py

* Модели == объект, хранящийся в БД (таблица).
* __Django ORM__ (Object Relational Mapping) является одной из самых мощных особенностей Django.  
  Оно позволяет нам взаимодействовать с базой данных, используя Python, а не SQL.
* Чтобы Django понял, что мы работаем с классом для моделей, необходимо наследоваться от базового
  класса: `models.Model`.
* Поле id (PK) создаётся по умолчанию. Когда создаётся объект и добавляются новые данные оно (id)
  автоматически инкрементируется (+1).
* Если мы хотим другое поле (столбец) сделать PK, то мы должны в аргументы типа данных стобца
  добавить `primary_key=True`.
* DEFAULT_AUTO_FIELD в `settings.py` хранит в себе тип данных id (PK), созданного по умолчанию.
* Not NULL всегда стоит по умолчанию

В классе models находятся классы типов данных SQL. По типу CharField, TextField.  
Ещё для каждого типа данных есть обязательные(1) и необязательные(2) аргументы поля.
По типу max_length=128(1), null=True(2).  
Подробнее можно узнать в <a href = 'https://docs.djangoproject.com/en/4.2/ref/models/fields/#primary-key'>
документации</a>.

Внутри класса мы создаём поля (столбцы) с определенными параметрами.

```
class ProductCategory(models.Model):
    name = models.CharField(max_length=128, unique=True)
    description = models.TextField(null=True, blank=True)
```

#### Foreign Key

* FK = `models.ForeignKey(to=TableName, on_delete=model.CASCADE)` - в данном случае при удалении 1 строки из TableName
  удалятся все строки, FK которых равен PK той строки. На продакшене его не используют, ведь это очень опасно.
* А вместо этого пользуются `on_delete=model.PROTECT`, тк с ним не получится удалить ни одной строки из TableName пока
  существуют зависимые строки в других таблицах.
* Также существует `on_delete=model.SET_DEFAULT`, которая после удаления родителя ставит в переменную какое-то значение
  по умолчанию `default=data`, которое тоже надо указать в аргументах.

#### Миграции

БД можно чекнуть через админку Django

Чтобы перенести структуру наших классов на SQL-язык и в дальнейшем получить работу в БД необходимо выполнить миграцию.  
__Миграция__ - перенос структуры модели на структуру БД.

Команды:

* `manage.py makemigrations` - создание новых миграций.  
  После её выполнения создаётся программа в папке migrations приложений с изменениями в migrations.py с более подробным
  кодом того, что будет переведено в SQL и загружено в БД.
* `manage.py migrate` - применений миграций.
  После её выполнения создадутся/изменятся объекты (таблицы/столбцы) в БД. Название получившиеся таблицы выглядит так
  AppName_TableName.

#### Работа с моделями через консоль

1. Заходим в консоль и пишем `python manage.py shell`.
2. Далее импортируем классы с моделями `from products.models import ProductCategory`.
3. Создаём экземпляры класса `category = ProductCategory(name="одежда", description="удобная")`.
4. Сохраняем строку в БД `category.save()`

* Мы можем получить доступ к значениям строки. `category.id`, `category.pk`, `category.name`, `category.description`.
* `print(category)` выведет <ProductCategory: ProductCategory object (1)> - 1 элемент из таблицы ProductCategory.

Можно переопределить `def __str__(self)` внутри класса и при print(category) получать, например, category.name:

```
def __str__(self):
    return self.name
```

#### QuerySet

* Без переопределения `__str__` в модели в консоли будет выводиться <ClassName: ClassName object (id)>,

Это набор запросов (Query == запрос), которые представляют собой набор объектов из базы данных.  
Они работают через класс object, что являются экземпляром класса Manager, который в свою очередь является интерфейсом,
через который операции запроса базы данных предоставляются моделям Django

Методы QuerySet:

* create(data1=...) - cоздает объект из БД.
* get(condition1=,...) - возвращает объект из БД.
* all() - возвращает список всех объектов из БД.
* filter(condition1,...) - возвращает список объектов из БД по определенному признаку.
* ...<a href='https://docs.djangoproject.com/en/4.2/ref/models/querysets/'> Документация</a>.

В отличие от прошлого метода создания объектов тут нужна всего лишь одна строка вместо 2.

```
ProductCategory.objects.create(name="одежда", description="удобная")
```

Аналогия QuerySet в SQL (в сложных методах SQL-запросы очень большие):

* all() == SELECT * FROM products_product
* filter(quantity=5) == SELECT * FROM products_product WHERE quantity=5

#### Работа с моделями через админку

* Приложение `auth` в `settings.py` INSTALLED_APPS отвечает за работу с пользователями.
* Без переопределения `__str__` в модели в админке название будет вида `ClassName object (id)`.
* `auth_user` - таблица со всеми данными про пользователей.

`python manage.py createsuperuser` - создание аккаунта админа.

Чтобы отобразить модели в админке необходимо зайти в `admin.py` в каталоге приложения и зарегистрировать их.

```
from products.models import ProductCategory, Product

admin.site.register(Product)
admin.site.register(ProductCategory)
```

Добавление объектов (строк) через админку:

1. Нажать на плюсик
2. Записать нужные данные
3. Сохранить :(:

#### Работа с моделями в контроллерах и шаблонах

Views:

1. Импортируем модель во views.py (from products.models import Product, ProductCategory)
2. Вместе кучи строк передаем в context объект класса модели. (context = {'products': Product.object.all(),...)

Шаблоны:

* Всё так же, как и раньше

#### Работа с media:

* В `static` находятся статические файлы - изображения, файлы стилей css, скриптов javascript и так далее.
* В `media` находятся файлы, например, которые загружают пользователи на сервер.
* Папку `media`  надо располагать в корне проекта.

В `settings.py` обязательно надо добавить (желательно под STATIC блок):

* MEDIA_URL = '/media/'
* MEDIA_ROOT = BASE_DIR / 'media'

В `models.py` в `ImageField` `upload_to=DirectoryName` менять не надо. Благодаря изменениям в настройках указанная
папка создастся в каталоге `media` и изображения будут загружаться в неё.

Чтобы шаблоны имели доступ к `media` файлам в `urls.py` необходимо сделать валидными пути для работы с ними
(это сугубо для локального отображения):

```
from django.conf.urls.static import static
from django.conf import settings

if settings.DEBUG == True:
    urlpatterns += static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT)
```

`Product.object().first().image` выглядит так `<ImageFieldFile: относительный путь>`.

* Чтобы получить из этого объекта относительный путь на нужную нам картинку необходимо  
  вызвать встроенный в тип данных ImageFieldFile метод url(), который выведет путь в виде строки.

Поэтому в шаблоне делаем так: `{{product.image.url}}`.

### Django Fixtures

__Fixtures__ это наборы данных (структуры и объекты), которые Django может прочитать и загрузить в свою базу данных.

* Они удобны для восстановления структуры БД и её объектов.
* Допустимые форматы: JSON, XML, YAML.

__Создание фикстур:__

1. Создаём папку `fixtures` в каталоге приложения.
2. `python manage.py dumpdata AppName.ModelName > AppName/fixtures/file_name.format`

__Загрузка фикстур:__

1. Делаем миграции
2. `python manage.py loaddata AppName/fixtures/file_name.format (path_to_fixture_file)`

__Работа с ошибкой UnicodeDecodeError:__

Чтобы решить данную проблему необходимо поменять в уже созданных "дефектных" файлах стандарт кодирования на UTF-8 через
блокнот (с очень большими файлами работать не получится):

* Открываем файл через pycharm -> снизу выбираем UTF-8 -> Convert

### Работа с urls.py

* На месте первого параметра path стоит относительный путь. Если он является пустой строкой, то речь идёт о пути к
  главной странице сайта.
* На месте второго параметра path стоит ссылка на контроллер (ссылка попадает в функцию path и уже там вызывается с
  параметром request).
* Далее могут стоять разнообразные kwargs. Например, name='some_name' название пути для динамических ссылок {% url
  'name' %} в шаблонах.

#### Пространство имён (namespace) в диспетчере URL:

__Было:__

```
*store/urls.py*
urlpatterns =[
...
path('products/', products, name='products')
]
```

Стало:

```
*store/urls.py*
from django.urls import path, include
...
urlpatterns =[
...
path('products/', include('products.urls', namespace='products'))
]
```

Создаём папку `urls.py` в каталоге products

```
*products/urls.py*
app_name = "products"
urlpatterns =[
...
path('', products, name='index')
]
```

В данном случае мы разбили urls.py на два, где одно в корневой папке, а другое в папке приложения.  
При правильном использовании очень удобная вещь.

Что нужно сделать:

1. Добавить `from django.urls import path, include` в корневом `urls.py` и в зависимых по мере надобности.
2. `app_name = "AppName"` - в зависимых обязательно создать переменную app_name с названием приложения.
3. `path('products/', include('products.urls', namespace='products'))` - внутри include надо вставить ссылку на
   зависимый `urls.py` и name корневого urls, которое мы будем использовать при работе с динамическими ссылками.
4. `path('', products, name='index')` - в зависимом `urls.py`.

Если раньше в шаблоне использовалось `{% url 'products' %}` для перехода на view, соответствующий данному name, то
сейчас необходимо заменить `products` на `products:index`.

Все пути в `products.url` будут добавляться к url родителя.  
Те, чтобы попасть на view соответсвующий `path('test/', ...)` в `products.url` необходимо будет зайти
на `'products/test/'`.

### Работа с пользователями

#### Собственная модель пользователя:

В Django есть готовая модель пользователя (user) - `AbstractUser`.  
Воспользуемся (переопределим или дополним) ей вместо создания модели с нуля (наследование от `models.Model` и тд)

```
from django.db import models
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    image = models.ImageField(upload_to="user_images", null=True, blank=True)
```

В данном случае выскочит ошибка - БД надо перезаписать.  
При наличии фикстур это не создаст больших проблем.

1. Полностью удалить ДБ.
2. Добавить в настройках `AUTH_USER_MODEL` = 'AppName.ModelName' (В нашем случае 'users.User').
3. Сделать миграцию `python manage.py makemigrations` -> `python manage.py migrate`.
4. Загрузить фикстуры `python manage.py loaddata AppName/fixtures/file_name.format`.
5. Зарегистрировать модель в `admin.py` в `users` `admin.site.register(User)`.
